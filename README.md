# cj

is a small JIT framework written in C, with x86 and arm64 backends.

## what

- **multi-architecture support**: generates native code for:
  - **x86-64**
  - **ARM64** (except for 26 SIMD different-size instructions)
- **low-level API**: direct instruction emission, no high level constructs
- **no dependencies**: pure C with clib, nothing else

## how

the backends are autogenerated (check out `codegen`). x86 uses
[asmdb](https://www.npmjs.com/package/asmdb) as a data source, arm64 uses a
handgenerated file from [mra\_tools](https://github.com/alastairreid/mra_tools).

the rest is handwritten and basically trivial in the grand scheme of jit
compilation.

## why

because i wanted to understand the isa for both processor architectures and it
seemed like a fun project.

## quick start

### build

```bash
# dev build
make dev

# "prod" build
make all

# install (don't)
make install
```

### basic usage

```c
#include "ctx.h"
#include "op.h"

int main(void) {
  // Create JIT context
  cj_ctx* cj = create_cj_ctx();

  // Emit instructions
  cj_nop(cj);  // NOP
  cj_ret(cj);  // RET

  // Create executable function
  cj_fn f = create_cj_fn(cj);

  // Execute JIT-compiled code!
  f();

  // Cleanup
  destroy_cj_fn(cj, f);
  destroy_cj_ctx(cj);

  return 0;
}
```

you can find some more examples in the `examples` directory.

### requirements

- c11 compiler (gcc, clang)
- POSIX-compliant OS (for `mmap`)
- supported architecture (x86-64 or ARM64)

<hr/>

Have fun!
